import { LichessApi } from "./LichessApi";
import { Player, Color, Event } from "./types";
import { OpeningTreeBot } from "./bots/OpeningTreeBot";

/**
 * Game subscribes to gameId events and handles them posting moves
 * generated by player object that must implement two methods:
 *
 * getNextMove(array of uciMoves) returns uciMove
 * getReply(chat event) returns chat message
 */
class Game {
  /**
   * Initialise with interface to lichess.
   */

  api: LichessApi;
  name: string;
  player: Player;
  gameId!: string;
  colour!: Color;

  constructor(api: LichessApi, name: string, player: Player) {
    this.api = api;
    this.name = name;
    this.player = player;
    this.sayInChat = this.sayInChat.bind(this);
  }

  start(gameId: string) {
    this.gameId = gameId;
    this.api.streamGame(gameId, (event: Event) => this.handler(event));
  }

  handleChatLine(event: Event) {
    if (event.username !== this.name) {
      const reply = this.player.getReply(event);
      if (reply) {
        this.api.chat(this.gameId, event.room, reply);
      }
    }
  }

  handler(event: Event) {
    switch (event.type) {
      case "chatLine":
        this.handleChatLine(event);
        break;
      case "gameFull":
        this.colour = this.playingAs(event);
        this.playNextMove(event.state.moves);
        break;
      case "gameState":
        this.playNextMove(event.moves);
        break;
      default:
        console.log("Unhandled game event : " + JSON.stringify(event));
    }
  }

  sayInChat(msg: string) {
    this.api.chat(this.gameId, "player", msg);
  }

  playNextMove(previousMoves: string) {
    const moves = previousMoves === "" ? [] : previousMoves.split(" ");
    if (this.isTurn(this.colour, moves)) {
      (this.player as OpeningTreeBot)
        .getNextMove(moves, this.sayInChat)
        .then((nextMove: string) => {
          console.log(`\n\n nextmove: ${nextMove} \n\n`);
          if (nextMove) {
            console.log(
              this.name + " as " + this.colour + " to move " + nextMove
            );
            this.api.makeMove(this.gameId, nextMove);
          }
        });
    }
  }

  playingAs(event: Event) {
    return event.white.name === this.name ? "white" : "black";
  }

  isTurn(colour: Color, moves: string[]) {
    var parity = moves.length % 2;
    return colour === "white" ? parity === 0 : parity === 1;
  }
}

export { Game };
